# 7.5. Доступ к файлам

Существует потребность в коде, который имел бы доступ к файлам, заранее не подсоединенным к программам. Необходимо соеденить этот код для файлов со стандартным вводом и стандартным выводом, которые для программы автоматически предопределены операционной системой конкретной машины.

Одна из программ, в которой возникает такая необходимость, - это программа cat, объединяющая несколько именованных файлов и направляющая результат в стандартный вывод. Функция `cat` часто применяется для выдачи файлов на экран, а также как универсальный "коллектор" файловой информации для тех программ, которые не имеют возможности обратиться к файлу по имени. Например, команда
```bash
cat x.c y.c
```
направит в стандартный вывод содержимое файлов `x.c` и `y.c` (и ничего более).

## Функция `fopen` и структура `FILE`
Возникает вопрос: что надо сделать, чтобы именованные файлы можно было читать; иначе говоря, как связать внешние имена, придуманные пользователем, с инструкциями чтения данных?

На этот счет имеются простые правила. Для того чтобы можно было читать из файла или писать в файл, он должен быть предварительно открыт с помощью библиотечной функции `fopen`. Функция `fopen` получает внешнее имя типа `x.c` или `y.c`, после чего осуществляет некоторые организационные действия и "переговоры" с операционной системой и возвращает указатель, используемый в дальнейшем для доступа к файлу.

Этот указатель, называемый _указателем файла_, ссылается на структуру, содержащую информацию о файле (адрес буфера, положение текущего символа в буфере, открыт файл на чтение или на запись, были ли ошибки при работе с файлом и не встретился ли конец файла). Пользователю не нужно знать подробности, поскольку определения, полученные из `<stdio.h>`, включают описание такой структуры, называемой `FILE`.

Единственное, что требуется для определения указателя файла, - это задать описания такого, например, вида:
```c
FILE *fp;
FILE *fopen(char *name, char *mode);
```
Это говорит, что `fp` есть указатель на `FILE`, a fopen возвращает указатель на `FILE`. Заметим, что `FILE` - это имя типа, наподобие int, а не метка структуры. Оно определено с помощью `typedef`.

Первый аргумент - строка, содержащая имя файла. Второй аргумент несет информацию о режиме. Это тоже строка: в ней указывается, каким образом пользователь намерен применять файл. Возможны следующие режимы: чтение (_read_ - "`r`"), запись (_write_ - "`w`") и добавление (_append_ - "`a`"), т. е. запись информации в конец уже существующего файла. В некоторых системах различаются текстовые и бинарные файлы; в случае последних в строку режима необходимо добавить букву "`b`" (_binary_ - бинарный).

Тот факт, что некий файл, которого раньше не было, открывается на запись или добавление, означает, что он создается (если такая процедура физически возможна). Открытие уже существующего файла на запись приводит к выбрасыванию его старого содержимого, в то время как при открытии файла на добавление его старое содержимое сохраняется. Попытка читать несуществующий файл является ошибкой. Могут иметь место и другие ошибки; например, ошибкой считается попытка чтения файла, который по статусу запрещено читать. При наличии любой ошибки fopen возвращает `NULL`.

## Чтение и запись символов в файл: функции `getc` и `putc`
Следующее, что нам необходимо знать, - это как читать из файла или писать в файл, коль скоро он открыт. Существует несколько способов сделать это, из которых самый простой состоит в том, чтобы воспользоваться функциями `getc` и `putc`. Функция `getc` возвращает следующий символ из файла; ей необходимо сообщить указатель файла, чтобы она знала откуда брать символ.
```c
int getc(FILE *fp);
```
Функция `getc` возвращает следующий символ из потока, на который указывает `*fp`; в случае исчерпания файла или ошибки она возвращает `EOF`.

Функция `putc` пишет символ c в файл `fp`
```c
int putc(int с, FILE *fp);
```
и возвращает записанный символ или `EOF` в случае ошибки. Аналогично `getchar` и `putchar`, реализация `getc` и `putc` может быть выполнена в виде макросов, а не функций.

При запуске Си-программы операционная система всегда открывает _три файла_ и обеспечивает три файловые ссылки на них. Этими файлами являются: стандартный ввод, стандартный вывод и стандартный файл ошибок; соответствующие им указатели называются `stdin`, `stdout` и `stderr`; они описаны в `<stdio.h>`. Обычно `stdin` соотнесен с клавиатурой, а `stdout` и `stderr` - с экраном. Однако `stdin` и `stdout` можно связать с файлами или, используя конвейерный механизм, соединить напрямую с другими программами, как это описывалось в параграфе 7.1.

Файловые указатели `stdin` и `stdout` представляют собой объекты типа `FILE *`. Это константы, а не переменные, следовательно, им нельзя ничего присваивать.

С помощью `getc`, `putc`, `stdin` и `stdout` функции __`getchar`__ и __`putchar`__ теперь можно определить следующим образом:
```c
#define getchar() getc(stdin)
#define putchar(c) putc((c), stdout)
```

Форматный ввод-вывод файлов можно построить на функциях __`fscanf`__ и __`fprintf`__. Они идентичны `scanf` и `printf` с той лишь разницей, что первым их аргументом является указатель на файл, для которого осуществляется ввод-вывод, формат же указывается вторым аргументом.
```c
int fscanf(FILE *fp, char *format, ...)
int fprintf(FILE *fp, char *format, ...)
```

## Функция `fclose`
Функция

```c
int fclose(FILE *fp)
```

- обратная по отношению к `fopen`; она разрывает связь между файловым указателем и внешним именем (которая раньше была установлена с помощью `fopen`), освобождая тем самым этот указатель для других файлов. Так как в большинстве операционных систем количество одновременно открытых одной программой файлов ограничено, то файловые указатели, если они больше не нужны, лучше освобождать, как это и делается в программе `cat`. Есть еще одна причина применить `fclose` к файлу вывода, - это необходимость "опорожнить" буфер, в котором `putc` накопила предназначенные для вывода данные. При нормальном завершении работы программы для каждого открытого файла `fclose` вызывается автоматически. (Вы можете даже закрыть `stdin` и `stdout`, если они вам не нужны. Воспользовавшись библиотечной функцией __`freopen`__, их можно восстановить.)

## Реализация программы `cat`

[Тут](../examples/cat_v1.c).

---

Запуск без аргументов (стандарный поток ввода):
```bash
% gcc cat_v1.c -o my_cat
% ./my_cat
my text
```
Далее Enter и Control + C. Вывод:
```
my text
```
---
Запуск `input.txt`:
```bash
% ./my_cat input.txt
my text
```
Вывод:
```
hex: 0xABC, s = fscanf
float <- 3.14
```
---
Запуск `input.txt`:
```bash
% ./my_cat input.txt input.txt
my text
```
Вывод:
```
hex: 0xABC, s = fscanf
float <- 3.14hex: 0xABC, s = fscanf
float <- 3.14
```

## Пример использования `fscanf`

[Тут](../examples/fscanf_usage.c):

```c
#include <stdio.h>

int main() {
  FILE* f = fopen("input.txt", "r");
  unsigned int x;
  char s[100];
  float pi;
  int n = fscanf(f, "hex: %x, s = %s\nfloat <- %f", &x, s, &pi);
  fclose(f);

  printf("x = %d, s = %s, pi = %f, n = %d", x, s, pi, n);

  return 0;
}
```

Для файла `input.txt`.
```
hex: 0xABC, s = fscanf
float <- 3.14
```

Вывод
```
x = 2748, s = fscanf, pi = 3.140000, n = 3
```
